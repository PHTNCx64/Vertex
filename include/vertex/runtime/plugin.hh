//
// Copyright (C) 2026 PHTNC<>.
// Licensed under GPLv3.0 with Plugin Interface exceptions.
//
#pragma once

#include <filesystem>
#include <sdk/api.h>
#include <sdk/feature.hh>
#include <sdk/statuscode.h>

// these are auto generated
#include "plugin_move_semantics.hh"
#include "plugin_functions.hh"

namespace Vertex::Runtime
{
    class Plugin final
    {
      public:
        Plugin() = default;
        ~Plugin();

        void set_path(const std::filesystem::path& path) noexcept
        {
            m_path = path;
        }

        [[nodiscard]] const std::filesystem::path& get_path() const noexcept
        {
            return m_path;
        }

        [[nodiscard]] std::string get_filename() const noexcept
        {
            return m_path.filename().string();
        }

        [[nodiscard]] const PluginInformation& get_plugin_info() const noexcept
        {
            return m_pluginInfo;
        }

        [[nodiscard]] PluginInformation& get_plugin_info() noexcept
        {
            return m_pluginInfo;
        }

        void set_plugin_handle(void* handle) noexcept
        {
            m_pluginHandle = handle;
        }

        [[nodiscard]] void* get_plugin_handle() const noexcept
        {
            return m_pluginHandle;
        }

        [[nodiscard]] bool operator==(const Plugin& other) const noexcept
        {
            return m_path == other.m_path;
        }

        [[nodiscard]] bool operator!=(const Plugin& other) const noexcept
        {
            return !(*this == other);
        }

        Plugin(const Plugin&) = delete;
        Plugin& operator=(const Plugin&) = delete;

        Plugin(Plugin&& other) noexcept
            : m_pluginInfo(other.m_pluginInfo),
              m_path(std::move(other.m_path)),
              m_pluginHandle(other.m_pluginHandle),
              VERTEX_PLUGIN_MOVE_INIT_LIST // Auto-generated by the build system
        {
            other.m_pluginHandle = nullptr;
            VERTEX_PLUGIN_MOVE_NULLIFY // Auto-generated by the build system
        }

        Plugin& operator=(Plugin&& other) noexcept
        {
            if (this != &other)
            {
                m_pluginInfo = other.m_pluginInfo;
                m_path = std::move(other.m_path);
                m_pluginHandle = other.m_pluginHandle;

                VERTEX_PLUGIN_MOVE_ASSIGN_COPY // Auto-generated by the build system

                other.m_pluginHandle = nullptr;
                VERTEX_PLUGIN_MOVE_ASSIGN_NULLIFY // Auto-generated by the build system
            }
            return *this;
        }

      private:
        PluginInformation m_pluginInfo{};
        std::filesystem::path m_path{};
        void* m_pluginHandle{};
    
      public:
        VertexRuntime m_runtime{};

        VERTEX_PLUGIN_FUNCTION_POINTERS // Auto-generated by the build system

        void unload();

        [[nodiscard]] bool is_loaded() const noexcept
        {
            return m_pluginHandle != nullptr;
        }

        [[nodiscard]] bool has_feature(const uint64_t feature) const noexcept
        {
            return (m_pluginInfo.featureCapability & feature) != 0;
        }
    };
}
